现在您已经掌握了基本知识，您需要学习如何使用CLI，构建更复杂的应用程序，并为实际工作打下坚实的知识基础。在本教程中，我们将构建一个小型的联系人管理应用程序，演示各种Aurelia的特性，并学习一些有用的技术。

## Setting Up Your Machine

在本教程中，我们将使用Aurelia CLI。如果您已经用CLI安装了您的机器，您可以跳到下一节。如果没有，那么请安装以下CLI先决条件

*   安装NodeJS 4.x或更高版本。
    *   You can [download it here](https://nodejs.org/en/) .
*   安装Git客户端
    *   Here's [a nice GUI client](https://desktop.github.com) .
    *   Here's [a standard client](https://git-scm.com) .

>
在为Windows安装Git时，有一个选项可以`只使用Git bash`、`从Windows命令提示符运行Git`，或者`从Windows命令提示符运行Git和包含unix工具`。您必须`选择在windows命令提示符中运行git`，或者在`windows命令提示符中运行包含unix工具的git`，以使Aurelia CLI能够工作。

安装了先决条件之后，就可以安装Aurelia CLI本身了。在命令行中，使用`npm`全局安装CLI:

``` shell
npm install aurelia-cli -g
```

>
>始终从Bash提示符运行命令。根据环境的不同，在执行npm全局安装时可能需要使用`sudo`。

>
>虽然创建一个新项目不需要NPM 3，但是前端开发通常需要一个扁平的包结构，这在3之前的NPM版本中是不可用的。建议您更新到NPM 3，它将能够管理这个结构需求。您可以使用`npm -v`检查您的NPM版本。如果需要更新，运行`npm install npm -g`。


## Creating A New Aurelia Project

现在，您已经完成了机器设置，我们可以创建contact manager应用程序。要创建项目，请从命令行运行`au new`。您将看到许多选项。将项目命名为“contact-manager”，然后选择“Default ESNext”或“Default TypeScript”选项，这取决于什么最适合您。(本教程中不要选择“Custom”。)

一旦您做出了选择，CLI将显示您的选择，并询问您是否愿意创建文件结构。按回车键接受默认的“是”。之后，您将被问到是否愿意安装新项目的依赖项。也可以按enter键选择默认的“yes”。

一旦安装了依赖项(需要几分钟)，项目就可以开始了。只需将目录更改为项目文件夹，并通过键入`au run --watch`运行它。这将运行应用程序，并查看项目的源代码进行更改。打开web浏览器并导航到CLI输出中所示的url。如果所有设置都正确，您应该会在浏览器中看到“Hello World!”

## Adding Required Assets 添加所需资源

在本教程中，我们将使用一个假的内存后端。我们还预先创建了CSS和一些实用函数，所以我们不必在这里浪费时间。在我们开始编写应用程序之前，您需要下载这些必需的资产并将它们添加到您的项目中。

<div style="text-align: center; margin-bottom: 32px">[Download the Contact Manager Assets](http://aurelia.io/downloads/contact-manager-assets.zip)</div>

下载zip文件后，解压缩它，您将发现三个文件:

*   `web-api.js` - The fake, in-memory backend.假的、内存中的后端。
*   `utility.js` - 应用程序使用的一些辅助功能
*   `styles.css` - 这个应用程序的样式

将所有这些文件复制到项目的`src`文件夹。TypeScript用户还应该将文件扩展名从`.js`重命名为`.ts`。

## Building the Application Shell 构建应用程序Shell
在继续之前，请确保您熟悉在[创建Todo应用程序](https://github.com/sansantang/aurelia_translate/blob/master/%E6%95%99%E7%A8%8B/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.MD)时引入的概念，或者对Aurelia有一些基本的经验。本文不讨论[创建Todo应用程序](https://github.com/sansantang/aurelia_translate/blob/master/%E6%95%99%E7%A8%8B/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.MD)所涉及的主题。

让我们从本教程最终产品的图片开始。它将帮助我们看到应用程序的结构和我们需要构建的部分。

![The Final Contact Manager App](https://aurelia.io/docs/tutorials/creating-a-contact-manager/img/contact-app-final.png)

在图中，您可以看到顶部有一个标题，左侧有一个联系人列表，其余部分由一个细节窗格填充。我们将把应用程序的整体结构称为应用程序的外壳或布局。

首先，我们将通过配置路由器来设置`App`类。我们希望浏览器历史记录反映选择了列表中的哪个联系人，因此我们将引入一个客户端路由器来处理屏幕之间的导航。用以下代码替换您的`app.ts`中的代码
app.js
 

``` typescript
import {Router, RouterConfiguration} from 'aurelia-router';
  import {PLATFORM} from 'aurelia-pal';
  
  export class App {
    router: Router;
  
    configureRouter(config: RouterConfiguration, router: Router){
      config.title = 'Contacts';
      config.map([
        { route: '',              moduleId: PLATFORM.moduleName('no-selection'),   title: 'Select' },
        { route: 'contacts/:id',  moduleId: PLATFORM.moduleName('contact-detail'), name:'contacts' }
      ]);
  
      this.router = router;
    }
  }  
```

>
>在修改了上面的代码之后，如果您立即尝试编译，您可能会在单元测试上收到一个编译错误，因为样例测试引用了我们刚刚修改的App类。要解决这个问题，请删除虚拟单元测试。

要向您的应用程序添加路由，您所要做的就是向您的`App`类添加一个`configureRouter`方法。框架将调用此方法，并将`RouterConfiguration`和`Router`路由器传递给它。您可以使用`configuration`对象来获得路由设置。使用`map`方法将路由模式映射到应该处理模式的模块。至少，每个路由都需要至少一个`路由模式`和一个`moduleId`。

在上面的例子中，我们正在注册两条路由。 第一条路由是空的，由`route: ''`。 这将是没有片段时匹配的默认路由。 此路由将导致无选择模块（`no-selection` module）加载。 如果他们没有选择要查看的联系人，我们将使用它向用户显示一条好消息。 第二条路线具有模式`contacts/:id`。 这将匹配文字`contacts/`后跟一个参数，我们将其命名为`id`。 当此路由匹配时，路由器将加载联系详细信息(`contact-detail`)模块，以便我们可以显示所选联系人。

>
>您注意到对`PLATFORM.moduleName(....)`的调用了吗?这是一个在Aurelia Webpack项目中使用的特殊API，它允许Webpack标识表示模块的字符串。这使得Webpack能够在构建的包中包含引用的模块。

这种配置还有一些兴趣点。 首先，请注意我们已经设置了`config.title`属性。 这将设置一个基本“标题”，用于浏览器的文档标题。 我们还可以在每条路由上设置标题`title`。 当我们这样做时，路由器的标题和匹配的路线的标题将连接在一起形成最终的文档标题。 要注意的第二件事是第二个路由有一个 `name`属性。 我们以后可以使用它来生成路由，而无需在任何地方复制/粘贴路由模式。 相反，我们可以按名称引用路线。


现在我们已经配置了应用程序的导航结构，我们需要将可视化结构放置到位。为此，使用以下标记替换您的 `app.html`文件：

app.hml
 
``` typescript
<template>
    <require from="./styles.css"></require>
  
    <nav class="navbar navbar-light bg-light fixed-top" role="navigation">
      <a class="navbar-brand" href="#">
        <i class="fa fa-user"></i>
        <span>Contacts</span>
      </a>
    </nav>
  
    <div class="container">
      <div class="row">
        <div class="col-md-4">Contact List Placeholder</div>
        <router-view class="col-md-8"></router-view>
      </div>
    </div>
  </template>
  
```

关于这个观点，有几件有趣的事情值得注意。首先，查看视图顶部的`require`元素。这就是我们如何“导入”或“需要”各种资源到我们的视图中。它的视图相当于ES 2015年的“导入”语法。正如JavaScript是模块化的，并且需要导入其他资源，Aurelia视图也是如此。在本例中，我们表示希望引入自定义样式。

在`require`元素下面，您可以看到一个非常标准的结构。我们有一些HTML在顶部设置导航栏。下面是应用程序的主容器div，它有两列。第一个包含我们的联系人列表，由占位符div表示。第二个包含一个`router-view` 自定义元素。


`router-view`由Aurelia提供，它是一个占位符，指示路由器应该在何处呈现当前路由。这允许您按照自己的意愿构造应用程序布局，只需将`router-view`放置在希望看到当前页面呈现的任何位置。无论何时您有一个`configureRouter`方法，视图也必须包含一个`router-view`。

我们几乎完成了应用程序shell的设置。在完成之前，我们需要安装引导程序并将其导入到主文件中。为了让我们的应用程序有一个良好的外观，我们将在本教程中使用它。在你自己的应用程序中，你可以使用任何你喜欢的CSS框架。

要获得引导设置，我们首先使用NPM安装库本身。在命令行上执行以下操作：

``` shell
npm install bootstrap --save
  npm install font-awesome --save
```

接下来，我们需要在`main.ts`中导入它。将以下行添加到文件的顶部：

``` javascript
   import 'bootstrap/dist/css/bootstrap.css';
  import 'font-awesome/css/font-awesome.css';
```

>
>每当您在应用程序中安装新的依赖项时，请确保重新启动`au run`或分别启动`au run -watch`命令，以便CLI重新打包新添加的依赖项。

## Building Out the Default Route 构建默认路由

If you run the application now, using `au run --watch`, you'll see a compile error similar to:

``` groovy
 ERROR in ./src/app.js
  Module not found: Error: Can't resolve 'contact-detail' in '/contact-manager/src'
```
This is actually expected. Why? Well, we use `PLATFORM.moduleName(....)` as part of our route configuration, but we haven't actually created these modules. Let's create them now. Create a new file under `src` named `no-selection.ts` and give it the following code:

no-selection.js

``` typescript
export class NoSelection {
    message = "Please Select a Contact.";
  }
```

  This will provide the basic functionality for our "no selection" screen. All we want to do is display a message to our end user to select a contact. Now, let's add a view to render this view-model. Create another file named `no-selection.html` and add that to your `src` folder with the following contents:

  no-selection.html
  

``` html
<template>
    <div class="no-selection text-center">
      <h2>${message}</h2>
    </div>
  </template>
```
All it does is provide a container with some styling in order to display our message to the user.

Next, let's just add a placeholder module for our contact detail screen, so we can satisfy the build. Create a new file under `src` named `contact-detail.ts` and give it the following code:

contact-detail.js

``` javascript
export class ContactDetail {}
```
With this in place, you should now be able to run your application. If you haven't stopped/restarted it after editing the bundles, then you will need to do that now. When you run the application, you should see something similar to this:
![enter description here](https://aurelia.io/docs/tutorials/creating-a-contact-manager/img/contact-app-no-selection.png)
  

  
## Building Out the Contact List

We've got the basic visual structure of our application in place and routing is now working. We've even created our first screen. However, it's not very interesting. We've got a `div` placeholder for the actual contact list at present. Let's go ahead and build that out, as a `contact-list` custom element.

Aurelia strives to be a self-consistent framework. As such, building a custom element is the same as creating your `App` component and your routed components. To create the `contact-list` custom element, start by creating a new file named `contact-list.ts` and add the following code:

contact-list.js

``` typescript
import {WebAPI} from './web-api';
  import {inject} from 'aurelia-framework';
  
  @inject(WebAPI)
  export class ContactList {
    contacts;
    selectedId = 0;
  
    constructor(private api: WebAPI) { }
  
    created() {
      this.api.getContactList().then(contacts => this.contacts = contacts);
    }
  
    select(contact) {
      this.selectedId = contact.id;
      return true;
    }
  }
```

 >We use a dashed naming convention to separate the words _contact-list_ as our custom element name. The name of the class instead should be defined by using the UpperCamelCase version _ContactList_.

  The view-model for our custom element has a few notable characteristics. First, we're using dependency injection. Aurelia has its own dependency injection container, which it uses to instantiate classes in your app. Classes can declare constructor dependencies through _inject metadata_. This looks a bit different depending on what language you are using. In ES 2015, you can declare an `inject` static method that returns an array of constructor dependencies while in ES Next and TypeScript, you can use an `inject` decorator to declare those dependencies. As you can see here, our `ContactList` class has a dependency on our `WebAPI` class. When Aurelia instantiates the contact list, it will first instantiate (or locate) an instance of the web API and "inject" that into the contact list's constructor.

The second thing to notice is the `created` method. All Aurelia components follow a component life-cycle. A developer can opt into any stage of the life-cycle by implementing the appropriate methods. In this case, we're implementing the `created` hook which gets called after both the view-model and the view are created. We're using this as an opportunity to call our API and get back the list of contacts, which we then store in our `contacts` property so we can bind it in the view.

Finally, we have a `select` method for selecting a contact. We'll revisit this shortly, after we take a look at how it's used in the view. On that note, create a `contact-list.html` file and use the following code for the view:

contact-list.html

``` html
<template>
    <div class="contact-list">
      <ul class="list-group">
        <li repeat.for="contact of contacts" class="list-group-item ${contact.id === $parent.selectedId ? 'active' : ''}">
          <a route-href="route: contacts; params.bind: {id:contact.id}" click.delegate="$parent.select(contact)">
            <h4>${contact.firstName} ${contact.lastName}</h4>
            <p>${contact.email}</p>
          </a>
        </li>
      </ul>
    </div>
  </template>
```

  The markup above begins by repeating an `li` for each contact of our contacts array. Take a look at the class attribute on the `li`. We've used an interesting technique here to add an `active` class if the contact's id is the same as the `selectedId` of the contact on our `ContactList` view-model. We've used the `$parent` special value to reach outside of the list's scope and into the parent view-model so we can test against that property. Throughout the list template, we've used basic string interpolation binding to show the `firstName`, `lastName` and `email` of each contact.

Take special note of the `a` tag. First, we are using a custom attribute provided by Aurelia's routing system: `route-href`. This attribute can generate an `href` for a route, based on the route's name and a set of parameters. Remember how we named the contacts route in our configuration? Here we're using that by referencing the "contacts" route name and binding the contacts's `id` parameter as the route's `id` parameter. With this information, the router is able to generate the correct `href` on the `a` tag for each contact. Additionally, we've also wired up a `click` event. Why would we do this if the `href` is already going to handle navigating to the correct contact? Well, we're looking for instant user feedback. We want the list selection to happen ASAP, so we don't have to wait on the navigation system or on the loading of the contact data. To accomplish this, we use the `select` method to track the selected contact's `id`, which allows us to instantly apply the selection style. Finally, normal use of `.trigger` or `.delegate` causes the default action of the event to be cancelled. But, if you return true from your method, as we have done above, it will be allowed to continue. Thus, when the user clicks on the contact, we immediately select the contact in the list and then the `href` is allowed to trigger the router, causing a navigation to the selected contact.

Ok, now that we've got the contact list built, we need to use it. To do that, update your `app.html` with the following markup:

app.html

``` typescript
<template>
    <require from="./styles.css"></require>
    <require from="./contact-list"></require>
  
    <nav class="navbar navbar-light bg-light fixed-top" role="navigation">
      <a class="navbar-brand" href="#">
        <i class="fa fa-user"></i>
        <span>Contacts</span>
      </a>
    </nav>
  
    <div class="container">
      <div class="row">
        <contact-list class="col-md-4"></contact-list>
        <router-view class="col-md-8"></router-view>
      </div>
    </div>
  </template>
```
There are two important additions. First, we've added another `require` element at the top, to import our new `contact-list` into this view. Remember that views are encapsulated, just like modules. So, this makes the `contact-list` visible from within this view. Second, we now use the custom element, right above our `router-view`.

If you go ahead and run the application, you should now see something like this:
![enter description here](https://aurelia.io/docs/tutorials/creating-a-contact-manager/img/contact-app-contact-list.png)
  

## Building Out the Contact Detail Screen

Ok, things are starting to come together, but we still can't view an individual contact. If you try selecting something from the list, you'll see an error like the following in the console:
  

``` 
ERROR [app-router] Error: Unable to find module with ID: contact-detail.html
```

Again, this is because the router is trying to route to the detail screen, but we only have a stub component with no view. So, let's build out the real detail component. Replace the contents of `contact-detail.ts` with the following code:

contact-detail.js
 

``` typescript
import {inject} from 'aurelia-framework';
  import {WebAPI} from './web-api';
  import {areEqual} from './utility';
  
  interface Contact {
    firstName: string;
    lastName: string;
    email: string;
  }
  
  @inject(WebAPI)
  export class ContactDetail {
    routeConfig;
    contact: Contact;
    originalContact: Contact;
  
    constructor(private api: WebAPI) { }
  
    activate(params, routeConfig) {
      this.routeConfig = routeConfig;
  
      return this.api.getContactDetails(params.id).then(contact => {
        this.contact = <Contact>contact;
        this.routeConfig.navModel.setTitle(this.contact.firstName);
        this.originalContact = JSON.parse(JSON.stringify(this.contact));
      });
    }
  
    get canSave() {
      return this.contact.firstName && this.contact.lastName && !this.api.isRequesting;
    }
  
    save() {
      this.api.saveContact(this.contact).then(contact => {
        this.contact = <Contact>contact;
        this.routeConfig.navModel.setTitle(this.contact.firstName);
        this.originalContact = JSON.parse(JSON.stringify(this.contact));
      });
    }
  
    canDeactivate() {
      if (!areEqual(this.originalContact, this.contact)) {
        return confirm('You have unsaved changes. Are you sure you wish to leave?');
      }
  
      return true;
    }
  }
```

Once again, we are using dependency injection to get an instance of our `WebAPI`. We need this to load the contact detail data. Next, we implement a method named `activate`. Remember when we mentioned that all components have a life-cycle? Well, there are additional life-cycle methods for _routed components_. `activate` is one such method and it gets invoked right before the router is about to activate the component. This is also how the router passes the component its route parameters. Let's dig in a bit more.

The first argument passed to `activate` is the `params` object. This object will have one property for every route param that was parsed as well as a property for each query string parameter. If you recall, our route pattern for the contact details screen was `contacts/:id`. So, our `params` object will have an `id` property with the requested contact's id. Using this `id` we call our `WebAPI` to retrieve the contact data. This API returns a `Promise` which we wait on and then store the loaded contact in a `contact` property so it's easy to bind to. We also make a copy of this object and store it in the `originalContact` property, so we can do some rudimentary checking to see if the data has been edited by the user at a later point.

The second argument passed to `activate` is the `routeConfig`. This is the same configuration object that you created to configure the router itself. You can get access to that here so that you can access any of its properties. The router generates a `navModel` for each `routeConfig`. Using the `navModel` you can dynamically set the title of the document for this route. So, we call `navModel.setTitle()` in order to set up the document's title with the name of the contact that we just loaded.

This screen demonstrates another part of the navigation lifecycle available to routed components: the `canDeactivate` hook. If present, this method is called before navigating away from the current component. It gives your component an opportunity to cancel navigation, if it desires. In the case of the contact detail screen, we are comparing our `originalContact` to the current `contact`, using our `areEqual` helper method, in order to determine whether or not the user has made any changes to the data. If they have, we show a confirmation dialog to make sure they want to navigate away, since they would lose their changes. If the `canDeactivate` hook returns `true`, navigation is allowed; if false is returned, it is prevented and the route state is reverted.

If we take a brief look at the `save` method, we can see that this is just a brief call to the `WebAPI`'s `saveContact` method. After that succeeds, we update our `originalContact` to the latest version and then we update the document's title with the potentially new contact name.

Finally, we have a `canSave` computed property which we'll use in the view. This will help us show some simple feedback to the user to indicate whether the UI and data are in a state that allows for saving.

With that all in place, let's look at the view that will render this component. Create a new file named `contact-detail.html`.

contact-detail.html

``` typescript
<template>
    <div class="card">
      <div class="card-header text-white bg-primary">
        <h3>Profile</h3>
      </div>
      <div class="card-body">
        <form role="form">
          <div class="form-group">
            <label class="col-sm-3 col-form-label">First Name</label>
            <div class="col-sm-9">
              <input type="text" placeholder="first name" class="form-control" value.bind="contact.firstName">
            </div>
          </div>
  
          <div class="form-group">
            <label class="col-sm-3 col-form-label">Last Name</label>
            <div class="col-sm-9">
              <input type="text" placeholder="last name" class="form-control" value.bind="contact.lastName">
            </div>
          </div>
  
          <div class="form-group">
            <label class="col-sm-3 col-form-label">Email</label>
            <div class="col-sm-9">
              <input type="text" placeholder="email" class="form-control" value.bind="contact.email">
            </div>
          </div>
  
          <div class="form-group">
            <label class="col-sm-3 col-form-label">Phone Number</label>
            <div class="col-sm-9">
              <input type="text" placeholder="phone number" class="form-control" value.bind="contact.phoneNumber">
            </div>
          </div>
        </form>
        <div>
          <button class="btn btn-success float-right" click.delegate="save()" disabled.bind="!canSave">Save</button>
      </div>
      </div>
    </div>
  </template>
```

Don't be intimidated by the amount of HTML above. It's mostly all basic form controls and bootstrap structures. If you look at the `input` elements, you will see that they all have a two-way binding to the appropriate contact's properties. The only real interesting part is the `button` element at the bottom. This button invokes `save` when clicked, but notice that it also has its `disabled` attribute bound to our `canSave` property. The result is that the user won't be able to save if the API is in the middle of a request or if there is missing contact information.

You should now be able to select contacts in the list, see their details, edit them, save and even see the confirm dialog on unsaved data navigations. It should look something like this:
![enter description here](https://aurelia.io/docs/tutorials/creating-a-contact-manager/img/contact-app-contact-detail.png)
  
## Adding Pub/Sub Messaging

If you play around with the application for a bit, you'll notice a few "buggy" behaviors:

*   Refreshing the browser with a contact selected results in the correct contact being shown, but not in the correct contact list item being highlighted.
*   If you edit some data, try to navigate away and then cancel, the contact list item selection will go out of sync, highlighting the contact you were going to before you cancelled, but not the current contact.
*   If you edit some data and save, you will notice that changes in the name are not reflected in the list.

The reason for these issues is that we have two separate components, our `contact-list` and our `contact-detail` which both have their own internal data structures and behaviors, but which do have an affect on each other. The router is controlling the contact detail screen, so it's the ultimate source of truth and the contact list should sync with it. To handle this, we're going to increase the amount of information in our system by introducing pub/sub. Let's create a couple of messages that our `contact-detail` component can publish and then let the `contact-list` subscribe to those and respond appropriately.

message.js

``` typescript
export class ContactUpdated {
    constructor(public contact) { }
  }
  
  export class ContactViewed {
    constructor(public contact) { }
  }
```
Whenever the contact detail screen successfully saves a contact, we'll publish the `ContactUpdated` message and whenever the end user begins viewing a new contact, we'll publish the `ContactViewed` message. Each of these messages will carry the contact data along with it so that subscribers have contextual data related to the event. Next, let's update our `contact-detail` code to incorporate Aurelia's `EventAggregator` and publish the messages at the appropriate time:

contact-detail.js
 

``` typescript
import {inject} from 'aurelia-framework';
  import {EventAggregator} from 'aurelia-event-aggregator';
  import {WebAPI} from './web-api';
  import {ContactUpdated,ContactViewed} from './messages';
  import {areEqual} from './utility';
  
  interface Contact {
    firstName: string;
    lastName: string;
    email: string;
  }
  
  @inject(WebAPI, EventAggregator)
  export class ContactDetail {
    routeConfig;
    contact: Contact;
    originalContact: Contact;
  
    constructor(private api: WebAPI, private ea: EventAggregator) { }
  
    activate(params, routeConfig) {
      this.routeConfig = routeConfig;
  
      return this.api.getContactDetails(params.id).then(contact => {
        this.contact = <Contact>contact;
        this.routeConfig.navModel.setTitle(this.contact.firstName);
        this.originalContact = JSON.parse(JSON.stringify(this.contact));
        this.ea.publish(new ContactViewed(this.contact));
      });
    }
  
    get canSave() {
      return this.contact.firstName && this.contact.lastName && !this.api.isRequesting;
    }
  
    save() {
      this.api.saveContact(this.contact).then(contact => {
        this.contact = <Contact>contact;
        this.routeConfig.navModel.setTitle(this.contact.firstName);
        this.originalContact = JSON.parse(JSON.stringify(this.contact));
        this.ea.publish(new ContactUpdated(this.contact));
      });
    }
  
    canDeactivate() {
      if(!areEqual(this.originalContact, this.contact)){
        let result = confirm('You have unsaved changes. Are you sure you wish to leave?');
  
        if(!result) {
          this.ea.publish(new ContactViewed(this.contact));
        }
  
        return result;
      }
  
      return true;
    }
  }
```
First, notice that we've both imported Aurelia's `EventAggregator` and configured it to be injected into the constructor of our `ContactDetail` class. We've also imported the two messages we created. Whenever a contact is loaded, we publish the `ContactViewed` message. Whenever a contact is saved, we publish the `ContactUpdated` message. Finally, if the user attempts to navigate away, but cancels, we reflect this by publishing another `ContactViewed` message, representing that they are returning to view the current contact.

With these messages in place, we can now enable any other component in our system to loosely subscribe to the new information in our system and use that data as appropriate to its internal needs. We'll go ahead and update the `contact-list` component to take advantage of this information to ensure that it is always in sync:
  
contact-list.js

``` typescript
 import {EventAggregator} from 'aurelia-event-aggregator';
  import {WebAPI} from './web-api';
  import {ContactUpdated, ContactViewed} from './messages';
  import {inject} from 'aurelia-framework';
  
  @inject(WebAPI, EventAggregator)
  export class ContactList {
    contacts;
    selectedId = 0;
  
    constructor(private api: WebAPI, ea: EventAggregator) {
      ea.subscribe(ContactViewed, msg => this.select(msg.contact));
      ea.subscribe(ContactUpdated, msg => {
        let id = msg.contact.id;
        let found = this.contacts.find(x => x.id == id);
        Object.assign(found, msg.contact);
      });
    }
  
    created() {
      this.api.getContactList().then(contacts => this.contacts = contacts);
    }
  
    select(contact) {
      this.selectedId = contact.id;
      return true;
    }
  }
```



As you can see, we've just imported and injected our `EventAggregator` and then it's as simple as calling the `subscribe` method and passing it the message type and a callback. When the message is published, your callback is fired and passed the instance of the message type. In this case, we use these messages to update our selection as well as the details of the contact that are relevant to our list.

If you run the application now, you should see that everything is working as expected.





## Adding A Loading Indicator

Let's add one more final touch to this application. Whenever we're navigating from screen to screen or making a `WebAPI` request, let's show a loading indicator at the top of our app. To do this, we'll use a 3rd party library and create a custom Aurelia element to wrap it up.

Begin by installing the `nprogress` library with the following command:

``` shell
npm install nprogress --save
```

 >**TypeScript Definition Files**
TypeScript users should note that when using 3rd party libraries, in order to make them work in a TypeScript project, you may need to acquire (or create) d.ts files. See TypeScript's official documentation, if you encounter issues.

  
With that in place, let's create our `loading-indicator` custom element. In the `src/resources/elements` folder create a file named `loading-indicator.ts` and use the code below for its implementation:

loading-indicator.js

``` typescript
import * as nprogress from 'nprogress';
  import {bindable, noView, PLATFORM} from 'aurelia-framework';
  import 'nprogress/nprogress.css';
  
  @noView
  export class LoadingIndicator {
    @bindable loading = false;
  
    loadingChanged(newValue) {
      if (newValue) {
        nprogress.start();
      } else {
        nprogress.done();
      }
    }
  }
  
```

  This code creates a custom element, but we're doing a few unique things here. First, since the entire rendering job is handled by the NProgress library, we don't need Aurelia's templating engine to render this component at all. So, we use the `noView()` decorator to tell Aurelia not to load a `loading-indicator.html`, compile it or do any of that rendering work. Additionally, the NProgress library requires some CSS to work, so we make sure to import that above.

Next, we want our custom HTML element to have a `loading` property that we can bind to via an HTML attribute in the DOM. So, we declare that by using the `bindable` decorator. Whenever you have a `bindable`, by convention, you can optionally declare a _propertyName_Changed method that will be called whenever the binding system updates the property. So, we've added one of those so that we can toggle the NProgress indicator off and on, based on the value of that property.

Previously, when we created the `contact-list` component, we required that into the `app.html` view and used it, since all views are encapsulated. However, we're going to do something different in this case, as an example. Aurelia actually gives you the ability to globalize view resources, such as custom elements. This is a convenience so that you don't have to require common resources repeatedly into every view. To do this, we need to register our element as a global resource. Open up the `resources/index.ts` file that's already in your solution, and change the code so that it has the registration as follows:

  resources/index.js
 

``` typescript
 import {FrameworkConfiguration, PLATFORM} from 'aurelia-framework';
  
  export function configure(config: FrameworkConfiguration) {
    config.globalResources([PLATFORM.moduleName('./elements/loading-indicator')]);
  }
```
With this registration in place, we can now use our new indicator in our `app.html`, but before we do that, we want to make one more change to our `app.ts`. We would like to be able to bind the indicator to the request state of our API, so we need to make that available in our `App` class. Update your `app.ts` as follows:
  
app.js

``` typescript
import {Router, RouterConfiguration} from 'aurelia-router';
  import {inject, PLATFORM} from 'aurelia-framework';
  import {WebAPI} from './web-api';
  
  @inject(WebAPI)
  export class App {
    router: Router;
  
    constructor(public api: WebAPI) {}
  
    configureRouter(config: RouterConfiguration, router: Router) {
      config.title = 'Contacts';
      config.map([
        { route: '',              moduleId: PLATFORM.moduleName('no-selection'),   title: 'Select'},
        { route: 'contacts/:id',  moduleId: PLATFORM.moduleName('contact-detail'), name:'contacts' }
      ]);
  
      this.router = router;
    }
  }
  
```
Ok, now that we've got an `api` property we can bind to, update your `app.html` to the final version that adds the `loading-indicator` and binds its `loading` property:

app.html

``` typescript
<template>
    <require from="./styles.css"></require>
    <require from="./contact-list"></require>
  
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="navbar-header">
        <a class="navbar-brand" href="#">
          <i class="fa fa-user"></i>
          <span>Contacts</span>
        </a>
      </div>
    </nav>
  
    <loading-indicator loading.bind="router.isNavigating || api.isRequesting"></loading-indicator>
  
    <div class="container">
      <div class="row">
        <contact-list class="col-md-4"></contact-list>
        <router-view class="col-md-8"></router-view>
      </div>
    </div>
  </template>
  
```
And with that, we've finished our app. Congratulations!


## Next Steps

Now that you've completed the tutorial, you may want to consider doing some additional research or development exercises to continue your learning and hone your skills. Here are a few ideas:

*   Create a real backend for the app and use the [http-client or fetch-client](docs/plugins/http-services) to retrieve the data.
*   Extend that application so that new contacts can be added.
*   Extend the contact detail form with data validation.
*   Learn more about [the component life-cycle](docs/fundamentals/components#the-component-lifecycle).
*   Learn more about [the navigation life-cycle and routing](docs/fundamentals/cheat-sheet#routing).
*   Expand your knowledge of [binding](docs/binding/basics) and [templating](docs/templating/basics).


## Conclusion

This tutorial presents a fairly simple application, but it provides an opportunity to demonstrate a number of interesting techniques. We hope it's helped you along in the process of learning Aurelia and we look forward to seeing what things you will build next.

  
  


  

