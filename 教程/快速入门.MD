* [Setup](#setup)
* [The Index\.html Page](#the-indexhtml-page)
* [The Todo Class](#the-todo-class)
* [The App Class](#the-app-class)
* [Getting Ready to Render 准备渲染](#getting-ready-to-render-%E5%87%86%E5%A4%87%E6%B8%B2%E6%9F%93)
* [Rendering the App 开始渲染应用程序](#rendering-the-app-%E5%BC%80%E5%A7%8B%E6%B8%B2%E6%9F%93%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)
* [总结](#%E6%80%BB%E7%BB%93)

## Setup

Aurelia是一个惊人的框架，它包含简单和干净的代码，而不牺牲能力。在本教程中，我们将通过构建一个“Todo”应用程序向您介绍Aurelia的简单性。您将看到您的应用程序代码是多么干净和简单，并且您将了解Aurelia的一些基本概念和功能。

Before we start writing some code, you'll need to get setup with a basic project structure. There are several ways to setup Aurelia, including using our command line tools, Webpack, Yeoman or our skeletons. However, to start you out, we're going to show you a basic script-tag setup that requires no additional tools or build systems. Please begin by downloading the basic script setup by clicking the button below.

在我们开始编写一些代码之前，您需要使用基本的项目结构进行设置。有几种方法可以设置Aurelia，包括使用命令行工具、Webpack、Yeoman或骨架。然而，首先，我们将向您展示一个基本的脚本标记设置，它不需要额外的工具或构建系统。请单击下面的按钮下载基本脚本设置。

[Download the Basic Aurelia Project Setup](http://aurelia.io/downloads/basic-aurelia-project.zip)


通过这个设置，您可以在两种流行的编程语言选项中进行选择:`ESNext`和`TypeScript`。如果您希望严格遵循符合规范的下一代`ECMAScript`，您将希望使用ESNext选项。但是，如果您喜欢强类型和丰富的编译时验证以及语言工具，那么您将希望使用`TypeScript`。


一旦你做出了语言选择，你需要做两件事：

*   Configure this documentation to show all code samples in your preferred programming language.

配置此文档，以显示首选编程语言中的所有代码示例
*   Configure your Aurelia project to use your preferred programming language.

配置您的Aurelia项目，以使用您喜欢的编程语言


让我们首先配置这个文档。如果您向下滚动一点，并查看任何源代码示例的右侧，您将看到一个下拉列表，用于选择您喜欢的编程语言。单击该选项，并确保选择与您选择的语言相匹配的语言。

现在让我们设置您的项目。首先，将下载的文件解压到硬盘上。这样做将为您提供完成本教程并在之后继续学习和实验所需的默认文件夹结构和脚本。您还希望打开您喜爱的文本编辑器中的文件夹，以便在文件之间导航、编辑和添加新文件。我们需要查看的第一个文件是`index.html`。这是启动我们的应用程序的地方，也是我们配置您的编程语言选择的地方。您应该在`index.html`中看到类似的内容。

index.html
``` html
<!DOCTYPE html>
  <html>
    <head>
      <title>Aurelia</title>
    </head>
    <body aurelia-app="src/main">
      <script src="scripts/system.js"></script>
      <script src="scripts/config-typescript.js"></script>
      <script src="scripts/aurelia-core.min.js"></script>
      <script>
        System.import('aurelia-bootstrapper');
      </script>
    </body>
  </html>
```

在解释它的作用之前，让我们先调整一下它使用的编程语言。如果您查看第二个脚本标记，您将看到它的`src`指向`scripts/config-typescript.js`。这是`TypeScript`的配置。所以，如果你想使用`TypeScript`，你已经准备好了，不需要做任何修改。如果您想使用`ESNext`，您需要交换它的`src`，以便它指向`scripts/config-esnext.js`。

就是这样。您的语言选择现在已经配置了这些文档和您的新项目。

## The Index.html Page

如果你能坚持到这一步，现在你已经准备好了一切来帮助你学习Aurelia。让我们从更深入地看一看`index.html`文件开始。

index.html
``` html
<!DOCTYPE html>
  <html>
    <head>
      <title>Aurelia</title>
    </head>
    <body aurelia-app="src/main">
      <script src="scripts/system.js"></script>
      <script src="scripts/config-typescript.js"></script>
      <script src="scripts/aurelia-core.min.js"></script>
      <script>
        System.import('aurelia-bootstrapper');
      </script>
    </body>
  </html>
 
```

是的,就是这样。这是我们应用程序中唯一的HTML页面。有了这些，您可以使用Aurelia创建几乎任何类型的应用程序，您可以想象。让我们看看这个文件的每个元素，看看发生了什么。

首先，您可以看到这个文档被设置为一个标准的HTML5文档，具有doctype、html、head和body。我们感兴趣的项目位于body标签内(和上面)。让我们依次查看每个脚本标记。
``` html
<script src="scripts/system.js"></script>
```
  
  这个标签用于加载`SystemJS`，一个现代JavaScript模块加载器。因为Aurelia是一个现代框架，所以它是作为模块编写的，并鼓励您以模块化的方式创建代码。要在TypeScript中使用模块，需要一个理解模块代码的加载器。这就是SystemJS所做的。它定位模块，理解它们的依赖关系，并确保在运行时正确加载所有内容。Aurelia支持多种模块加载器。除了SystemJS, Aurelia还支持所有基于amd的加载器，如RequireJS、Cajon和Dojo。Aurelia还支持基于模块的构建系统，如Webpack。

``` html
<script src="scripts/config-typescript.js"></script>
```
  
  如前所述，这行代码配置您想要使用的编程语言。它实际上是SystemJS模块加载器的配置文件，在加载器中安装了一个转置器。因此，每次加载模块时，它都能够获取您的ESNext或TypeScript代码，并自动将其转换为今天的浏览器完全理解的ES5代码。很酷吧?
  
>在生产应用程序中，您不会像我们在这里所做的那样，在浏览器中使用换行器实时转换代码。这将执行得相当差，并要求您分发整个换行器与您的应用程序。我们在这里使用这项技术使您能够在不需要任何工具或构建设置的情况下开始。在后面的指南中，我们将向您展示如何使用CLI来设置一个准备好生产的项目，并完成自动应用程序构建和捆绑。

``` xml
<script src="scripts/aurelia-core.min.js"></script>
```
这是Aurelia本身的核心，在一个脚本文件中。您需要添加它来使用框架。这将支持我们在本指南中使用的所有酷功能。
  

``` javascript
 SystemJS.import('aurelia-bootstrapper');
```

  最后一个脚本标记有点不同。它提供了一些代码，而不是设置`src`。`SystemJS`对象由上面提到的SystemJS模块加载器提供。这里，我们调用它的一个api `import`。这个API告诉加载器加载或“导入”具有指定名称的模块。在本例中，我们加载的是`aurelia-bootstrapper`，它驻留在上面链接的`aurelia-core.min.js`文件中。这个模块包含Aurelia的“引导”或“启动”代码（"bootstrap" or "startup"）。这告诉Aurelia加载框架，配置它并运行您的应用程序。

还有一件事要注意。不知道你有没有注意到。在`body`标签上，有一个`aurelia-app` 属性。它指向`src/main`。这将告诉Aurelia的引导程序哪个模块包含框架配置，以及哪个HTML元素是将呈现应用程序的“host”元素。稍后我们将研究如何创建该文件。在此之前，我们想做一些非传统的东西。我们想向您展示如何在不使用任何Aurelia api的情况下，用普通的TypeScript构建整个Todo应用程序。然后，我们将使用Aurelia将应用程序呈现到屏幕上，而不更改任何TypeScript代码。

我知道你们会觉得这很有趣，所以让我们开始吧！


## The Todo Class

使用Aurelia可以做的一件了不起的事情是，使用普通的TypeScript为整个应用程序建模，这是任何其他框架或库都无法做到的。我们认为当你看到它的时候你就会明白了。

我们将从创建一个`Todo`类开始。因为我们正在制作一个Todo应用程序，所以我们需要一个类来为单独的Todo项目建模。在项目的`src`文件夹中，创建以下文件：

todo.ts
``` typescript
 export class Todo {
    done = false;
    constructor(public description: string) { }
  }
    
```

就是这样。它是一个普通类，它对todo的`description`文本建模，并使用一个boolean `done`来表示是否已经完成了todo。



## The App Class

   我们的todo应用程序包含一个`todo`实例列表。它可以添加和删除待办事项。通过允许用户提供todo描述来添加todo。一旦他们输入了一个描述并添加了todo，这个描述就会被清除，这样他们就可以创建另一个todo了。让我们为这些想法建模。这是`App`类:

  
app.ts
``` kotlin
import {Todo} from './todo';
  
  export class App {
    heading = "Todos";
    todos: Todo[] = [];
    todoDescription = '';
  
    addTodo() {
      if (this.todoDescription) {
        this.todos.push(new Todo(this.todoDescription));
        this.todoDescription = '';
      }
    }
  
    removeTodo(todo) {
      let index = this.todos.indexOf(todo);
      if (index !== -1) {
        this.todos.splice(index, 1);
      }
    }
  }
    
```

再一次，就是这么简单。让我们回顾一下我们建模的思想:
*   我们的应用程序的 `heading`是“Todos”.
*   todo列表被建模为`todos`属性表示的`Todo`实例数组.
*   可以添加(`addTodo`)或删除(`removeTodo`) Todo实例.
*   当实例被添加时，用户将向它们提供一个描述.
*   添加Todo之后，将清除描述以启用下一个添加.

太棒了。这是应用程序的所有TypeScript代码。但是Aurelia在哪里呢?答案是，Aurelia尽可能地远离你的TypeScript代码。这就是为什么你在上面看不到它。这不是必要的。Aurelia能够呈现普通的TypeScript对象。
  
## Getting Ready to Render 准备渲染

好了，现在我们已经在TypeScript中建模了我们的应用程序，我们需要让Aurelia渲染它。当我们在上面说我们已经向您展示了所有的TypeScript代码时，我们并不完全诚实。还有最后一件事能让一切顺利进行。

如果你还记得，当我们查看`index.html`时，`body`元素上有一个`aurelia-app`属性。 此属性告诉`aurelia-bootstrapper`在何处呈现应用程序以及用于配置应用程序的主文件。 该属性的值指向`src/main`。 那么，让我们在`src`文件夹中创建该文件，看看它的作用。

main.ts

``` typescript
import {Aurelia} from 'aurelia-framework';
  
  export function configure(aurelia: Aurelia) {
    aurelia.use.basicConfiguration();
    aurelia.start().then(() => aurelia.setRoot());
  }
  
```

>在使用TypeScript时，在这个简单的设置中，您可能会在代码编辑器中看到一些“曲线”。这是因为这个简单的设置没有以代码编辑器可以找到类型定义文件的方式配置。没什么好担心的，一切都会好的。在下一篇教程中，当我们设置一个可生产的项目时，这个问题将会消失。如果您有这方面的经验，您可以使用Typings来安装d.ts 在任何时候你都可以自己定义。


当我们像上面那样提供一个主文件时，我们能够告诉`Aurelia`如何通过简单地导出一个`configure`方法来配置它自己。该框架将提供一个Aurelia对象的实例，您可以以多种方式使用该实例。例如，您可以添加许多选项、插件和第三方扩展。在本例中，我们使用“基本配置”来配置Aurelia。然后，我们告诉框架“start”。一旦启动，我们告诉它“set root”。

那么，set root是什么意思呢?如果您将UI看作组件的层次结构，那么我们所做的就是配置该层次结构的“根”组件。这是Aurelia需要呈现的UI组件树的根。

下一个想法可能是“但是您没有说要呈现什么组件!”这个观点很好。Aurelia 能够不受干扰的一个方法是有一些基本的惯例。在这种情况下，我们有一个非常简单的约定。默认情况下，根目录是`app.js`，相对于`main.js`文件。如果您不喜欢这样，与所有Aurelia约定一样，您可以使用显式配置覆盖它。现在，让我们坚持惯例。

好了，我们差不多准备好运行我们的应用程序了。接下来要告诉Aurelia它应该如何渲染`app.js`.

## Rendering the App 开始渲染应用程序

简要回顾一下，请记住，到目前为止，我们所做的几乎都不是针对Aurelia的。我们编写的几乎所有代码都是普通的TypeScript。现在，我们已经向项目添加了一个`main`文件，并指定了哪个模块导出UI层次结构的根组件，Aurelia准备呈现。

为了渲染，我们需要为`app`组件创建一个视图。这介绍了`Aurelia`的下一个约定。要为任何类创建视图，只需创建与TypeScript模块同名的HTML文件，但将文件扩展名更改为`.html`。在该视图中，可以放置一个`HTML 5`模板，其中包含数据绑定表达式(_data binding expressions_)，声明视图应该如何呈现类的实例。让我们从应用程序的基本视图开始。

app.html
``` html
<template>
    <h1>${heading}</h1>
  </template>
  

  
```

这里有几件事需要注意。首先，所有视图都封装在一个Web component `template`元素中。其次，您注意到`${heading}`语法了吗?在视图内部，您可以访问与该视图关联的类实例的所有属性和方法，并且可以使用上面所示的TypeScript模板字符串语法在任何元素或属性的内容中访问它们。上面的语法创建了到`heading`属性的单向数据绑定。所谓“单向”是指数据流是单向的，只有对`heading`属性的更改才会影响视图。没有从视图返回到视图模型(view-model)的“反向”流。

>**表现模式**
>我们将视图的关联类称为视图模型，因为它是视图的模型或视图的模型。大多数Aurelia开发利用Model - View - View-Model模式。然而，如果需要，Aurelia足够灵活，还可以使用监视控制器、被动视图和Model - View - Controller等模式。

好了，现在我们有了一个视图，我们准备运行我们的应用程序。为此，我们需要启动一个web服务器来提供index.html页面，这样我们就可以在浏览器中查看它了。如何做到这一点取决于您希望使用哪种服务器端技术。下面是一些常见场景的说明：

*   **Visual Studio** - Open Visual Studio 2015\. Using the main menu, select File > Open > Web site... In the resulting dialog, choose the project folder then click the Open button. The folder contents will be displayed in the Visual Studio Solution Explorer window. Right click on index.html in Solution Explorer and select "View in Browser". This will fire up the development web server and serve index.html.
*   **Visual Studio** - Open Visual Studio 2015。使用主菜单，选择文件>打开>网站…在生成的对话框中，选择project文件夹，然后单击Open按钮。文件夹内容将显示在Visual Studio解决方案资源管理器窗口中。在“解决方案资源管理器”中右键单击index.html并选择“浏览器中的视图”。这将启动开发web服务器并提供index.html.
*   **NodeJS with npm** - To start up a simple web server in the project folder, first globally install the http-server command with `npm install http-server -g`. (In some environments you may need to use `sudo`). Once that is installed, change directory to the project folder. You can now spin up the server from within the folder with the following command `http-server -o -c-1`.
*   **NodeJS with npm** - 要在项目文件夹中启动一个简单的web服务器，首先使用`npm install http-server -g`全局安装http-server命令。(在某些环境中，您可能需要使用sudo)。安装完成后，将目录更改为项目文件夹。现在可以使用以下命令`http-server -o -c-1`从文件夹中启动服务器.
*   **NodeJS with yarn** - First install the http-server with `yarn add http-server`. Then use `yarn run http-server -o -c-1` to run the server.
*   **NodeJS with yarn** - 首先使用`yarn add http-server`安装http-server。然后运行`http-server -o -c-1`来运行服务器。.
*   **Firefox** - If you don't want to worry about setting up a web server, Firefox is flexible enough to serve the app directly from your hard drive. Simply open the `index.html` file with Firefox.
*   **Firefox** - 如果您不需要担心web服务器的设置，Firefox足够灵活，可以直接从您的硬盘上提供应用程序。只需用Firefox打开`index.html`文件。.


运行应用程序时，应该会看到应用程序呈现出`heading`属性，类似于这样:

![enter description here](https://aurelia.io/docs/tutorials/creating-a-todo-app/img/todo-app-with-heading.png)


在HTML中呈现属性似乎很简单，但是如何处理用户输入呢?让我们添加一些标记，使我们能够从用户获取输入来创建todos:

app.html
 ``` typescript
<template>
    <h1>${heading}</h1>
  
    <form submit.trigger="addTodo()">
      <input type="text" value.bind="todoDescription">
      <button type="submit">Add Todo</button>
    </form>
  </template>
  
```

现在，我们向视图添加了一个`form`。我们使用它从用户那里收集todo名称。看一下`input`。通过将`.bind`附加到`value`属性，我们已经告诉Aurelia，我们希望将它绑定到视图模型(view-model)上的`todoDescription`。在Aurelia中，您可以使用类似这样的简单属性表达式将任何HTML属性绑定到它的视图模型，只需添加`.bind`即可。

这里，我们要指出另一个重要的约定。当我们使用`.bind`时，Aurelia会根据您要绑定的*元素和属性*选择最合理的“**绑定模式**”。例如，由于这是一个输入，您正在绑定它的值，那么`.bind`将导致Aurelia设置一个双向绑定。这意味着，每当视图模型的`todoDescription`发生更改时，它将在输入的`value`属性中进行更新，而且每当输入的`value`属性发生更改时，视图模型也将更新其`todoDescription`。

不过，这个标记中还有一些值得注意的地方。我们不仅可以绑定属性，还可以将其附加到事件。看看 `form` 元素本身。在Aurelia中，您可以获取任何DOM事件并将`.trigger`附加到它。这意味着当该事件触发时，它将触发要计算的关联表达式。在本例中，`submit`事件导致调用`addTodo()`方法。因为我们已经使用了`submit`事件，这意味着todo将通过按submit按钮或在输入中按enter来添加。

>**绑定命令**
Aurelia will use two-way binding for all form control value bindings and one-way binding for everything else. However, you can always override this by using an explicit binding command. For example, instead of using .bind you can use .one-way, .two-way or .one-time. Similarly, you can use .delegate for event delegation in place of .trigger.
>Aurelia将对所有表单控件值绑定使用双向绑定，对其他所有内容使用单向绑定。但是，您总是可以通过使用显式绑定命令来覆盖它。例如，您可以使用`.one-way`、`.two-way`或`.one-time`来代替`.bind`。类似地，可以使用`.delegate`代替`.trigger`来进行事件委托。

If you run the app now, you should see something like this:
![enter description here](https://aurelia.io/docs/tutorials/creating-a-todo-app/img/todo-app-with-form.png)


尝试在输入框中键入并添加todo。您应该注意到，每次您这样做时，输入框都会被清空。原因是 `input`的`value` 具有双向（two way）绑定，我们的原始代码在添加了一个新的Todo实例后清除了`todoDescription`。这里是我们的`addTodo()`实现供参考:

The Add Todo Implementation
 ``` kotlin
addTodo() {
    if (this.todoDescription) {
      this.todos.push(new Todo(this.todoDescription));
      this.todoDescription = '';
    }
  }
  
```

嗯，我们现在可以添加待办事项了，但是我们看不到它们!让我们来看看Aurelia是如何处理数据列表的。更改标记以匹配此新版本：

app.html
``` html
<template>
    <h1>${heading}</h1>
  
    <form submit.trigger="addTodo()">
      <input type="text" value.bind="todoDescription">
      <button type="submit">Add Todo</button>
    </form>
  
    <ul>
      <li repeat.for="todo of todos">
        <input type="checkbox" checked.bind="todo.done">
        <span>
          ${todo.description}
        </span>
        <button click.trigger="removeTodo(todo)">Remove</button>
      </li>    
    </ul>
  </template>
  
```

要基于数组、映射或集合生成HTML，我们使用 `repeat.for="local of collection"`语法。该语法派生自 `for...of` 是TypeScript本身的循环。正如您在上面看到的，我们希望为todos数组中的每个条目生成一个`li`。所以，我们放一个`repeat.for`。对于`li`上的属性，我们希望生成并指定`todos`集合，我们希望将局部循环变量命名为`todo`。有了它，我们可以绑定到`todo`实例的任何属性。所以，你可以看到我们现在只是重新应用所有相同的技术。
我们将 `checked`属性绑定到todo的`done`属性，并将其`description`属性注入到`span`的内容中。最后，我们在按钮的`click`事件上添加一个`trigger`(触发器)，以便`removeTodo` 。注意，`removeTodo`仍然在作用域中。就像在TypeScript中一样，在循环内部，仍然可以访问外部块中的变量。这允许我们在App类上调用`removeTodo`方法，传递我们想要删除的特定`Todo`实例。

If you run the application again, you should now see something like this:
![enter description here](https://aurelia.io/docs/tutorials/creating-a-todo-app/img/todo-app-with-list.png)


我们快到了!少了一样东西。注意，如果勾选和取消勾选，什么也不会发生。在这种情况下，我们希望得到一些用户的反馈。也许划掉待办事项?让我们做一个视图的最终版本来添加它

app.html
``` html
<template>
    <h1>${heading}</h1>
  
    <form submit.trigger="addTodo()">
      <input type="text" value.bind="todoDescription">
      <button type="submit">Add Todo</button>
    </form>
  
    <ul>
      <li repeat.for="todo of todos">
        <input type="checkbox" checked.bind="todo.done">
        <span css="text-decoration: ${todo.done ? 'line-through' : 'none'}">
          ${todo.description}
        </span>
        <button click.trigger="removeTodo(todo)">Remove</button>
      </li>    
    </ul>
  </template>
  
```

最后一个例子展示了如何将css直接绑定到任何HTML元素上。它还展示了如何在任何属性中直接使用`${}`语法。在本例中，我们希望在todo的`done`属性为true时添加`line-through`到 `text-decoration`，否则我们希望使用`none`值。

>**style vs css attribute**
如果您关心支持这些浏览器，可以在执行字符串插值时使用样式属性的别名css来确保应用程序与Internet Explorer和Edge兼容。


Run the application one more time and you should see the expected result:

![Todo App With CSS](https://aurelia.io/docs/tutorials/creating-a-todo-app/img/todo-app-with-css.png)


## 总结

凭借其对开发人员体验的强烈关注，Aurelia不仅可以让您创建令人惊叹的应用程序，而且还可以享受这个过程。我们在设计它时考虑了一些简单的约定，这样您就不需要浪费时间进行大量的配置或编写样板代码来满足一个顽固的或限制性的框架。你和Aurelia也不会遇到障碍。它被精心设计成**可插拔**和**可定制**的……大多数情况下，你只是编写简单的TypeScript，而忘记了框架的存在。


感谢您抽出宝贵时间阅读我们的指南。 还有很多东西要学习和做！ 我们希望您继续阅读我们的[联系管理器教程](https://github.com/sansantang/aurelia_translate/blob/master/%E6%95%99%E7%A8%8B/%E8%81%94%E7%B3%BB%E4%BA%BA%E7%AE%A1%E7%90%86%E5%99%A8%E6%95%99%E7%A8%8B.MD)，了解如何使用Aurelia CLI获取生产级项目的设置，并使用一些更高级的功能，如`路由`，`发布/订阅`和`自定义元素`。

We're looking forward to seeing what you create!
