原文：https://aurelia.io/docs/binding/delegate-vs-trigger

* [1\.Delegate vs Trigger](#1delegate-vs-trigger)
  * [上述通用指南的例外情况:](#%E4%B8%8A%E8%BF%B0%E9%80%9A%E7%94%A8%E6%8C%87%E5%8D%97%E7%9A%84%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5)
    * [当满足下列条件时，在按钮上使用trigger触发器:](#%E5%BD%93%E6%BB%A1%E8%B6%B3%E4%B8%8B%E5%88%97%E6%9D%A1%E4%BB%B6%E6%97%B6%E5%9C%A8%E6%8C%89%E9%92%AE%E4%B8%8A%E4%BD%BF%E7%94%A8trigger%E8%A7%A6%E5%8F%91%E5%99%A8)
    * [在特定的iOS用例中使用trigger触发器click点击:](#%E5%9C%A8%E7%89%B9%E5%AE%9A%E7%9A%84ios%E7%94%A8%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8trigger%E8%A7%A6%E5%8F%91%E5%99%A8click%E7%82%B9%E5%87%BB)
* [2\.Event delegation with Capture 带有捕获的事件委托](#2event-delegation-with-capture-%E5%B8%A6%E6%9C%89%E6%8D%95%E8%8E%B7%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98)


## 1.Delegate vs Trigger

以下是一些常见的问题：

*   委托和触发器的区别是什么?
*   什么时候应该使用委托，什么时候应该使用触发器?

简短的回答是:**使用委托`delegate`，除非您不能使用委托`delegate`**。


事件委托是一种用于提高应用程序性能的技术。它利用了大多数DOM事件的“bubbling 冒泡”特性，从而极大地减少了事件订阅的数量。对于事件委托，处理程序不附加到单个元素。而是将单个事件处理程序附加到顶级节点(如body元素)。当一个事件冒泡出现在这个共享的顶级处理程序中时，事件委托逻辑根据事件的目标 [target](https://developer.mozilla.org/en-US/docs/Web/API/Event/target) 调用适当的处理程序。

要查明事件委托 [event delegation](https://davidwalsh.name/event-delegate) 是否可以用于特定事件，请使用谷歌`mdn [event name] event`。事实上，在使用`mdn`进行任何与web平台相关的谷歌搜索之前，通常都会从Mozilla开发人员网络返回高质量的结果。一旦你进入事件的MDN页面,检查事件是否`bubbling 冒泡`。只有冒泡事件可以与Aurelia的委托绑定命令一起使用。**`blur`、`focus`、`load`和`unload`事件不会冒泡，因此您需要使用`trigger`触发器绑定命令来订阅这些事件**。

这是[blur的MDN页面](https://developer.mozilla.org/zh-cn/docs/Web/Events/blur)。它有关于blur模糊和focus焦点事件的事件委托技术的进一步信息。

### 上述通用指南的例外情况:

#### 当满足下列条件时，在按钮上使用`trigger`触发器:

1.  您需要禁用按钮。
2.  按钮的内容由其他元素组成(而不仅仅是文本)。

这将确保对禁用按钮的子按钮的单击不会冒泡弹出到委托事件处理程序。更多信息请点击[这里](https://github.com/aurelia/binding/issues/163)。

#### 在特定的iOS用例中使用`trigger`触发器`click`点击:

iOS不冒泡点击事件的元素以外的`a`, `button`, `input` and `select`。如果您订阅了`click`一个非输入元素(如`div`)，并且目标是iOS，那么可以使用`trigger` binding命令。更多信息在[here](http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html)和[here](https://github.com/aurelia/binding/issues/263) .


## 2.Event delegation with Capture 带有捕获的事件委托

在大多数情况下，`delegate` 和 `trigger` 足以处理用户交互。然而，`delegate` 和 `trigger` 有时可能太晚而无法对事件做出反应。有时，事件可能永远不会到达您的`delegate` 和 `trigger`处理程序，当您与第三方插件生成的内容(元素)交互时就是这种情况。

在下面的示例中，`delegate` 和 `trigger`将**失败**：

**Capture command example**
```html
  <div class='my-plugin-container' click.delegate='onClickPluginContainer()'>
    <!--
      Content inside here is generated by a plugin
      That will call `event.stopPropagation()` on any click events
    -->
  </div>
```

您可能需要另一种方式来侦听`click`事件，即通过绑定命令`capture`（捕获）：

**Capture command example**
```html
  <div class='my-plugin-container' click.capture='onClickPluginContainer()'>
    <!--
      Content inside here is generated by a plugin
      That will call `event.stopPropagation()` on any click events
    -->
  </div>
```

在第二个例子中，无论是否在容器中调用`event.stopPropagation()`， `onClickPluginContainer()`都保证会发生。


随着 `capture`绑定命令的引入，您可能会问“哪个命令最适合处理事件?”

好的，以上的简短回答仍然是正确的，**使用`delegate`，除非你不能使用`delegate`**。捕获`capture`通常不需要，甚至可能令人困惑，因为它不是我们通常处理浏览器事件的方式。