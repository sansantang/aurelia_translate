原文链接：https://aurelia.io/docs/fundamentals/dependency-injection

了解如何利用Aurelia的依赖注入容器，这是Aurelia应用程序中所有对象创建背后的强大功能。

## Introduction 介绍

在构建应用程序时，通常需要采取“分而治之”的方法，将复杂的问题分解为一系列更简单的问题。在面向对象的世界中，这意味着将复杂对象分解为一系列更小的对象，每个对象关注一个关注点，并与其他对象协作，形成一个复杂的系统，并对其行为建模。

依赖注入容器是一种工具，可以简化分解这样一个系统的过程。通常，当开发人员进行系统破坏工作时，他们会在运行时引入一种新的复杂性，即重新“组装”较小的部件。这就是依赖注入容器可以为您做的，使用简单的声明性提示。


## Injection 注入

假设我们有一个`CustomerEditScreen` ，它需要通过ID从web服务加载一个 `Customer`实体。我们不希望将AJAX实现的所有细节都放在`CustomerEditScreen`类中。相反，我们希望将其分解到`CustomerService`类中，以便`CustomerEditScreen`或任何其他类在需要加载客户时使用。Aurelia的依赖注入容器允许您通过声明`CustomerEditScreen`需要在创建时注入`CustomerService`来实现这一点。

声明类依赖项的机制取决于您选择的编写应用程序所用的语言。通常，您会使用装饰器，这是Babel和TypeScript都支持的ES Next特性。下面是声明`CustomerEditScreen`需要`CustomerService`的样子：

**CustomerEditScreen Injection**

``` typescript
import {CustomerService} from 'backend/customer-service';
  import {inject} from 'aurelia-framework';
  
  @inject(CustomerService)
  export class CustomerEditScreen {
    constructor(private customerService: CustomerService) {
      this.customer = null;
    }
  
    activate(params) {
      return this.customerService.getCustomerById(params.customerId)
        .then(customer => this.customer = customer);
    }
  }
```

注意，我们使用注入 `inject`装饰器，构造函数签名匹配注入 `inject`装饰器中的依赖项列表。这告诉DI容器，每当它想要创建`CustomerEditScreen`的实例时，它必须首先获得`CustomerService`的实例，它可以在实例化期间将该实例注入`CustomerEditScreen`的构造函数。您可以根据需要拥有任意多的注入依赖项。只需确保注入装饰器和构造函数彼此匹配即可。下面是一个关于多个依赖项的快速示例：

**CustomerEditScreen Multiple Injection**

``` typescript
 import {CustomerService} from 'backend/customer-service';
  import {CommonDialogs} from 'resources/dialogs/common-dialogs';
  import {EventAggregator} from 'aurelia-event-aggregator';
  import {inject} from 'aurelia-framework';
  
  @inject(CustomerService, CommonDialogs, EventAggregator)
  export class CustomerEditScreen {
    constructor(private customerService: CustomerService, private dialogs: CommonDialogs, private ea: EventAggregator) {
      this.customer = null;
    }
  
    activate(params) {
      return this.customerService.getCustomerById(params.customerId)
        .then(customer => this.customer = customer)
        .then(customer => this.ea.publish('edit', customer));
    }
  }  
```

>要在Babel中使用装饰器，您需要`babel-plugin-transform-decorators-legacy` 插件。要在TypeScript中使用它们，需要向的`compilerOptions`部分添加`"experimentalDecorators": true`在 `tsconfig.json`文件中。Aurelia项目通常附带这些预先配置的选项。

如果您正在使用TypeScript，您可以利用该语言的一个实验性特性，让TypeScript转置器自动向Aurelia的DI提供类型信息。您可以通过使用`tsconfig.json`文件的`compilerOptions`部分中的`"emitDecoratorMetadata": true`选项配置TypeScript编译器来实现这一点。如果这样做，就不需要使用inject复制类型信息，相反，只要构造函数定义包含其参数的类型，就可以像这样使用Aurelia的自动注入（`autoinject`）装饰器：

**CustomerEditScreen AutoInjection with TypeScript**
 

``` typescript
import {CustomerService} from 'backend/customer-service';
  import {CommonDialogs} from 'resources/dialogs/common-dialogs';
  import {EventAggregator} from 'aurelia-event-aggregator';
  import {autoinject} from 'aurelia-framework';
  
  @autoinject
  export class CustomerEditScreen {
    constructor(private customerService: CustomerService, private dialogs: CommonDialogs, private ea: EventAggregator) {
      this.customer = null;
    }
  
    activate(params) {
      return this.customerService.getCustomerById(params.customerId)
        .then(customer => this.customer = customer)
        .then(customer => this.ea.publish('edit', customer));
    }
  }
  
```

>有趣的是，您根本不需要使用我们的自动注入 `autoinject`装饰器来实现上述功能。如果将任何装饰器添加到类中，TypeScript编译器将发出类型元数据。无论什么装饰器触发TypeScript添加元数据，Aurelia都可以读取该元数据。我们简单地提供了自动注入`autoinject`装饰器来保持一致性和清晰性。

如果您没有使用Babel或TypeScript的装饰器支持(或者不想使用)，那么可以使用类上的简单静态方法或属性轻松地提供注入`inject` 元数据：

**CustomerEditScreen Inject Method**

``` typescript
 import {CustomerService} from 'backend/customer-service';
  import {CommonDialogs} from 'resources/dialogs/common-dialogs';
  import {EventAggregator} from 'aurelia-event-aggregator';
  
  export class CustomerEditScreen {
    static inject = [CustomerService, CommonDialogs, EventAggregator];
  
    constructor(
      private customerService: CustomerService,
      private dialogs: CommonDialogs, 
      private ea: EventAggregator
    ) {
      this.customer = null;
    }
  
    activate(params: any) {
      return this.customerService.getCustomerById(params.customerId)
        .then(customer => this.customer = customer)
        .then(customer => this.ea.publish('edit:begin', customer));
    }
  }
  
```

除了静态注入方法之外，还支持静态注入属性。事实上，注入装饰器只是自动设置静态属性。只是语法糖。如果您想使用decorator（装饰器），但不想使用Aurelia的decorator，您甚至可以创建自己的decorator来设置相同的属性。

依赖注入的好处是它以递归的方式工作。例如，如果类A依赖于类B，类B依赖于类C和D，类D依赖于E、F和G，那么创建类A将导致层次结构中所需的所有类的解析。

## Object Lifetime, Child Containers and Default Behavior 对象生存期、子容器和默认行为

依赖注入容器创建的每个对象都有一个“生命周期”。有三种典型的终生行为:

*   **Container Singleton 容器单例** - A singleton class, `A`, is instantiated when it is first needed by the DI container. The container then holds a reference to class `A`'s instance so that even if no other objects reference it, the container will keep it in memory. When any other class needs to inject `A`, the container will return the exact same instance. Thus, the instance of `A` has its lifetime connected to the container instance. It will not be garbage collected until the container itself is disposed and no other classes hold a reference to it.
当DI容器第一次需要一个单例类A时，它将被实例化。然后容器持有对类a实例的引用，这样即使没有其他对象引用它，容器也会将它保存在内存中。当任何其他类需要注入A时，容器将返回完全相同的实例。因此，A的实例将其生存期连接到容器实例。在容器本身被处理并且没有其他类持有对它的引用之前，它不会被垃圾收集。

*   **Application Singleton 全局单例** - In Aurelia, it's possible to have child DI containers created from parent containers. Each of these child containers inherits the services of the parent, but can override them with their own registrations. Every application has a root DI container from which all classes and child containers are created. An application singleton is just like a container singleton, except that the instance is referenced by the root DI container in the application. This means that the root and all child containers will return the same singleton instance, provided that a child container doesn't explicitly override it with its own registration.
在Aurelia中，可以从父容器创建子DI容器。每个子容器都继承父容器的服务，但是可以用它们自己的注册覆盖它们。每个应用程序都有一个根DI容器，所有类和子容器都是从根DI容器创建的。应用程序单例与容器单例类似，只是实例由应用程序中的根DI容器引用。这意味着根容器和所有子容器将返回相同的单例实例，前提是子容器没有显式地用自己的注册覆盖它。

*   **Transient 瞬时** - Any DI container can create transient instances. These instances are created each time they are needed. The container holds no references to them and always creates a new instance for each request.
任何DI容器都可以创建临时实例。每次需要创建这些实例时都会创建它们。容器不包含对它们的引用，并且总是为每个请求创建一个新的实例。

任何类都可以在容器中注册为单例或瞬态`transient`(或自定义)。我们将在下一节中研究显式配置。然而，应用程序中的大多数类都是由Aurelia自动注册的。也就是说，没有预先配置，但是当第一次需要类`A`的实例时，它会自动注册，然后立即解析为实例。这个过程是什么样的?让我们看几个例子，看看实际情况如何。

### Example 1 - Root Container Resolution 根容器解析

Imagine that we have a single instance of `Container` called `root`. If a developer (or Aurelia) invokes `root.get(A)` to resolve an instance of `A`, the `root` will first check to see if it has a `Resolver` for `A`. If one is found, the `Resolver` is used to `get` the instance, which is then returned to the developer. If one is not found, the container will auto-register a `Resolver` for `A`. This resolver is configured with a _singleton_ lifetime behavior. Immediately after auto-registration, the `Resolver` is used to `get` the instance of `A` which is returned to the developer. Subsequent calls to `root.get(A)` will now immediately find a `Resolver` for `A` which will return the singleton instance.
假设我们有一个名为root的容器实例。如果一个开发人员(或Aurelia)调用root.get(a)来解析a的一个实例，根将首先检查它是否有一个针对a的解析器。如果没有找到，容器将自动为a注册一个解析器。该解析器配置为单例生存期行为。自动注册之后，解析器立即用于获取返回给开发人员的A的实例。接下来对root.get(A)的调用将立即为A找到一个解析器，该解析器将返回单例实例。

### Example 2 - Child Container Resolution 子容器解析

Now, imagine that we have a `Container` named `root` and we call `root.createChild()` to create a child container named `child`. Then, we invoke `child.get(A)` to resolve an instance of `A`. What will happen? First, `child` checks for a `Resolver` for `A`. If none is found, then it calls `get(A)` on its `parent` which is the `root` container from which it was created. `root` then checks to see if it has a `Resolver`. If not, it auto-registers `A` in `root` and then immediately calls the `Resolver` to `get` an instance of `A`.
现在，假设有一个名为root的容器，我们调用root. createchild()来创建一个名为child的子容器。然后，我们调用child.get(A)来解析A的一个实例。首先，子元素检查a的解析器，如果没有找到，那么它调用父元素上的get(a)，该父元素是创建它的根容器。然后root检查它是否有一个解析器。如果没有，它将在根目录中自动注册A，然后立即调用解析器来获取A的实例。

### Example 3 - Child Container Resolution with Override 带重写的子容器解析

Let's start with an instance of `Container` named `root`. We will then call `root.createChild()` to create a child container named `child`. Next we will call `child.createChild()` to create a grandchild container from it named `grandchild`. Finally, we'll call `child.registerSingleton(A, A)`. What happens when we call `grandchild.get(A)`? First, `grandchild` checks for a `Resolver`. Since it doesn't find one, it delegates to its `parent` which is the `child` from which it was created. `child` then checks for a `Resolver`. Since `child.registerSingleton(A, A)` was called on `child` this means that `child` will have a `Resolver` for `A`. At this point `child`'s resolver is used to `get` an instance of `A` which is returned to the developer.
让我们从一个名为root的容器实例开始。然后，我们将调用root.createChild()来创建一个名为child的子容器。接下来，我们将调用child.createChild()来从它创建一个名为grandchild的孙子辈容器。最后，我们将调用child。registerSingleton(A, A).当我们调用孙辈.get(A)时会发生什么?首先，孙儿检查解析器。因为它没有找到一个对象，所以它将委托给它的父对象，也就是创建它的子对象。然后，子元素检查是否有解析器。因为孩子。在child上调用registerSingleton(A, A)，这意味着child将有一个针对A的解析器。此时，子解析器用于获取返回给开发人员的A的实例。


As you can see from these examples, the `Container` basically walks its hierarchy until it either finds a `Resolver` or reaches the root. If no `Resolver` is found in the root, it auto-registers the class as a singleton in the root. This means that all auto-registered classes are application-wide singletons, unless they are overriden by a child container.
从这些示例中可以看到，容器基本上遍历其层次结构，直到找到解析器或到达根。如果在根中没有找到解析器，它会自动将类注册为根中的单例。这意味着所有自动注册的类都是应用程序范围内的单例类，除非它们被子容器覆盖。

## How Aurelia Uses Containers - Aurelia如何使用容器

Aurelia makes extensive use of DI throughout the framework. All view-models, components, services, etc. are created with DI. Aurelia also makes heavy use of child containers. The key to understanding the lifetime of your objects is in knowing how Aurelia uses child containers.

There are basically three cases where child containers get created and used by Aurelia, all essentially having to do with components.
Aurelia在整个框架中广泛使用了DI。所有视图模型、组件、服务等都是用DI创建的。奥雷里亚也大量使用儿童容器。理解对象生命周期的关键是了解Aurelia如何使用子容器。

基本上有三种情况下，Aurelia创建并使用子容器，所有这些基本上都与组件有关。

### Custom Elements and Custom Attributes 自定义元素和自定义属性

When Aurelia creates a View, that view may contain occurrences of custom elements and custom attributes. Any time an HTML element is found to either _be_ a custom element or _have_ custom attributes, Aurelia creates a child container for that element, parented to the closest custom element container (or the view itself). It then manually registers the elements/attributes in the child container as singletons. This ensures that the elements and attributes aren't singletons at the application level or even the view level, which would not make sense. Instead, they are scoped to their location in the DOM. As a result of this, the HTML behaviors have access to classes registered above them in the DOM and on the same element. Likewise, they can be injected into classes that are created through their child element containers.
当Aurelia创建视图时，该视图可能包含出现的自定义元素和自定义属性。每当发现HTML元素是自定义元素或具有自定义属性时，Aurelia就为该元素创建子容器，该容器是最近的自定义元素容器(或视图本身)的父容器。然后，它将子容器中的元素/属性手动注册为单例。这确保了元素和属性在应用程序级甚至视图级不是单例的，这是没有意义的。相反，它们的作用域仅限于DOM中的位置。因此，HTML行为可以访问上面在DOM和相同元素中注册的类。同样，可以将它们注入通过其子元素容器创建的类中。

>提示：Aurelia does not create child containers when there are plain HTML elements, or elements with only binding expressions, value converters, etc. It only creates them when the element itself is a custom element or if the element has custom attributes.
>提示：当有纯HTML元素时，或者只有绑定表达式、值转换器等元素时，Aurelia不会创建子容器。它只在元素本身是自定义元素或元素具有自定义属性时创建它们。

>警告：Despite that fact that the child container hierarchy is present in the DOM, you should be very wary of creating structural coupling between components in this way. The child container mechanism primarily exists to provide override services needed by custom elements and attributes such as `Element`/`DOM.Element`, `BoundViewFactory`, `ViewSlot`, `ElementEvents`/`DOM.Events`, `ViewResources` and `TargetInstruction`.
>警告：尽管子容器层次结构存在于DOM中，但是您应该非常谨慎地避免以这种方式在组件之间创建结构耦合。子容器机制主要用于提供自定义元素和属性(如元素/DOM)所需的覆盖服务。元素、BoundViewFactory、ViewSlot、ElementEvents/DOM。事件、视图资源和TargetInstruction。

### Routed Components 路由组件

Each time the `Router` navigates to a screen, it creates a child container to encapsulate all the resources related to that navigation event and then auto-registers the screen's view-model in that child container. As you know, auto-registration, by default, results in the view-model being registered as a singleton. However, it is possible to override this with explicit configuration, unlike custom elements and custom attributes, which are always container singletons.

### Dynamic Components 动态组件

Dynamic composition, whether through the `<compose>` element or through the `CompositionEngine`, also creates child containers with auto-registration behavior, just like the `Router`. In fact, the `RouteLoader` simply calls the `CompositionEngine` internally to do the heavy lifting.

### The General Rule for Aurelia's DI Use - Aurelia DI容器使用的一般原则

Everything is an application-level singleton except for those things which are classified as "components", essentially custom elements, custom attributes and view-models created through the router or composition engine. You can change the lifetime of router and composition created components through explicit configuration.
除了那些被分类为“组件”的东西(本质上是自定义元素、自定义属性和通过路由器或组合引擎创建的视图模型)之外，所有东西都是应用程序级的单例。您可以通过显式配置更改路由器的生存期和创建组件的组合。

## Explicit Configuration 显式配置

For the most part, Aurelia's DI will do what you want with object lifetime. However, you may desire to change the behavior of individual classes for the specific needs of your application. This is easy to do by either directly using the `Container` API or by decorating your class with a `Registration`.
在大多数情况下，Aurelia的DI将对对象生存期做您想做的事情。但是，您可能希望根据应用程序的特定需要更改各个类的行为。这很容易做到，可以直接使用容器API，也可以用注册装饰类。
 
### The Container Registration API 容器注册API

The usual way to configure a class's lifetime is to use the `Container` API directly. Typically, you will want to do this configuration up-front in your application's main `configure` method. The `Aurelia` instance that is provided during configuration has a `container` property which points to the root DI container for your application. Recall that any `Resolver` configured at the application root will apply unless a child container has explicitly overriden the behavior.

配置类生命周期的通常方法是直接使用容器API。通常，您希望在应用程序的主配置方法中预先执行此配置。配置过程中提供的Aurelia实例具有一个容器属性，该属性指向应用程序的根DI容器。请记住，除非子容器显式地覆盖了行为，否则在应用程序根上配置的任何解析器都将适用。

以下是您通过`Container`实例提供的注册API的调查：

*   `container.registerSingleton(key: any, fn?: Function): void` - 此方法允许您将类注册为单例。如上所述，这是默认值，因此很少有理由调用此方法。为了完整性，在API中提供了它。调用时，提供用于查找单例和应该使用的类的键。键和类相同是很常见的。如果它们是相同的，那么只需要提供 `key`。下面是一些例子:
    *   `container.registerSingleton(History, BrowserHistory);`
    *   `container.registerSingleton(HttpClient);`
*   `container.registerTransient(key: any, fn?: Function): void` -此方法允许您将类注册为`transient`。这意味着每当容器被要求提供键值时，它都会返回一个类的全新实例。与单例行为一样，`key` 是必须的，但类是可选的。如果关闭，键将被视为要实例化的类。下面是一个使用瞬态注册的例子:
    *   `container.registerTransient(LinkHandler, DefaultLinkHandler);`
*   `container.registerInstance(key: any, instance?: any): void` - 如果您已经有一个现有实例，您可以使用此方法将其添加到容器中。您只需要选择一个实例可通过其检索的键。如果没有提供键，则该键将成为实例。
*   `container.registerHandler(key: any, handler: (container?: Container, key?: any, resolver?: Resolver) => any): void` - In addition to simply declaring behaviors, you can also provide a custom function (a handler) that will respond any time the container is queried for the key. This custom handler has access to the container instance, the key and the internal resolver which stores the handler. This enables just about any sort of custom lifetime to be implemented by supplying a custom function. Here's an example:
除了简单地声明行为之外，您还可以提供一个自定义函数(一个处理程序)，该函数将在任何时候查询容器中的键时响应。这个自定义处理程序可以访问容器实例、密钥和存储处理程序的内部解析器。这允许通过提供自定义函数来实现任何类型的自定义生存期。这里有一个例子:
    *   `container.registerHandler('Foo', () => new Bar());`
*   `container.registerResolver(key: any, resolver: Resolver): void` - You can also register a custom `Resolver` instance for the key. Under the hood, all previously discussed methods translate to using a built-in `Resolver` instance. However, you can always supply your own. We'll discuss this in more detail in the DI customization article.
还可以为键注册自定义解析器实例。实际上，前面讨论的所有方法都转换为使用内置的解析器实例。然而，你总是可以提供你自己的。我们将在DI定制文章中更详细地讨论这个问题。
*   `container.autoRegister(fn: any, key?: any): Resolver` - As you know, if a container can't find a registration during its resolution stage, it will auto-register the requested type. That is done internally through the use of `autoRegister`. However, you can use it yourself to auto-register a type with a particular container instance. By default, this will result in a singleton registration, on the container this API is called on. However, if the type has registration decorators, that could provide an alternate registration. Whatever `Resolver` is established during auto-registration will be returned.
如您所知，如果容器在其解析阶段无法找到注册，它将自动注册所请求的类型。这是通过内部使用自动注册完成的。不过，您可以自己使用它向特定容器实例自动注册类型。默认情况下，这将导致在调用此API的容器上进行单例注册。但是，如果类型具有注册修饰符，则可以提供另一种注册。在自动注册期间建立的任何解析器都将返回。

>#### Registration Keys
>All registration APIs take a `key`. This key is typically the class itself (for convenience). However, the key can be _any_ type, including strings and objects. This is possible because Aurelia's DI implementation uses a `Map` object to correlate a _key_ to a `Resolver`. When using class-oriented registration APIs, if the key is not a class, you must provide the class to be created as the second argument to the API call.
>所有注册api都有一个键。这个键通常是类本身(为了方便起见)。但是，键可以是任何类型，包括字符串和对象。这是可能的，因为Aurelia的DI实现使用Map对象将键关联到解析器。当使用面向类的注册API时，如果键不是类，则必须提供要创建的类作为API调用的第二个参数。

### Registration Decorators 注册装饰者

As an alternative to explicitly registering types with the container, you can rely on auto-registration, but specify the auto-registration behavior you desire, overriding the default container-root-singleton behavior. To provide auto-registration behavior, you simply decorate your type with an auto-registration decorator. What follows is a basic explanation of built-in registration decorators:
作为显式向容器注册类型的替代方法，您可以依赖于自动注册，但要指定您希望的自动注册行为，覆盖默认的容器-root-singleton行为。要提供自动注册行为，只需使用自动注册装饰器装饰您的类型。下面是对内置注册装饰器的基本说明:

*   `transient()` - Simply decorate your class with `transient()` and when it's requested from the container, a new instance will be created for each request.
*   `singleton(overrideChild?:boolean)` - Normally, types are auto-registered as singletons in the root container. So, why do we provide this decorator? This decorator allows you to specify `true` as an argument to indicate that the singleton should be registered not in the root container, but in the immediate container to which the initial request was issued.
*   `registration(registration: Registration)` - In addition to the built-in singleton and transient registrations, you can create your own and associate it with a class. We'll discuss this in more detail in the DI customization article.

>#### Registration Decorator Usage
>At present, the Decorators spec allows for decorators to use parens or not depending on whether or not the decorator requires arguments. This means that decorator invocation is dependent on how the decorator was implemented internally, which can be confusing from time to time. As a result of the way that the registration decorators are implemented, you _must_ use them with parens.

## Resolvers

As mentioned above, the DI container uses `Resolvers` internally to provide all instances. When explicitly configuring the container, you are actually specifying what `Resolver` should be associated with a particular lookup key. However, there's a second way that resolvers are useful. Instead of supplying a key as part of the `inject` decorator, you can provide a `Resolver` instead. This resolver then communicates with the container to provide special resolution behavior, specific to the injection. Here's a list of the resolvers you can use in this capacity:

*   `Lazy` - Injects a function for lazily evaluating the dependency.
    *   ex. `Lazy.of(HttpClient)`
*   `All` - Injects an array of all services registered with the provided key.
    *   ex. `All.of(Plugin)`
*   `Optional` - Injects an instance of a class only if it already exists in the container; null otherwise.
    *   ex. `Optional.of(LoggedInUser)`
*   `Parent` - Skips starting dependency resolution from the current container and instead begins the lookup process on the parent container.
    *   ex. `Parent.of(MyCustomElement)`
*   `Factory` - Used to allow injecting dependencies, but also passing data to the constructor.
    *   ex. `Factory.of(CustomClass)`
*   `NewInstance` - Used to inject a new instance of a dependency, without regard for existing instances in the container.
    *   ex. `NewInstance.of(CustomClass).as(Another)`

If using TypeScript, keep in mind that `@autoinject` won't allow you to use `Resolvers`. Instead, you may use argument decorators, without duplicating argument order, which you otherwise have to maintain when using the class decorator or the static `inject` property. You also can use `inject` as argument decorator for your own custom resolvers, eg `constructor(@inject(NewInstance.of(HttpClient)) public client: HttpClient){...}`. Available build-in function parameter decorators are:

*   `lazy(key)`
*   `all(key)`
*   `optional(checkParent?)`
*   `parent`
*   `factory(key)`
*   `newInstance(asKey?, dynamicDependencies: [any])`

Here's an example of how we might express a dependency on `HttpClient` that we may or may not actually need to use, depending on runtime scenarios:

**Using Resolvers**

``` typescript
 import {lazy} from 'aurelia-framework';
  import {HttpClient} from 'aurelia-fetch-client';
  
  export class CustomerDetail {
    constructor(@lazy(HttpClient) private getHTTP: () => HttpClient){ }
  }
```
In this case, the `Lazy` resolver doesn't actually provide an instance of `HttpClient` directly. Instead, it provides a function that can be invoked at some point in the future to obtain an instance of `HttpClient` if needed.